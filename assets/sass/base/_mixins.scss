// SCSS mixins
// ---------------------------------------

// Breakpoints. Either set one to one of the breakpoint variables, or use a custom value for minor breakpoints.
// Defaults to min-width, but both min->max and max-width are available too.
// Parts based on https://gist.github.com/timknight/03e6335b8816aa534cf7
@mixin breakpoint($break: 0, $max: 0) {
  $value: type-of($break);
  @if $value == string {
    // If using 'break-1', 'break-2' etc output the correct breakpoints from map.
    @if map-has-key($breakpoints, $break) {
      @media screen and (min-width: #{map-get($breakpoints, $break) / 16 * 1em} ) { @content; }
    } @else {
      @warn "#{$break} is not a set breakpoint variable";
    }
  } @else if $value == number {
    // If using other numbers output value in ems either for min, min & max or max width breakpoints.
    $query: "all" !default;
    @if      $break != 0 and $max != 0 { $query: "(min-width: #{$break / 16 * 1em}) and (max-width: #{$max / 16 * 1em})"; }
    @else if $break != 0 and $max == 0 { $query: "(min-width: #{$break / 16 * 1em})"; }
    @else if $break == 0 and $max != 0 { $query: "(max-width: #{$max / 16 * 1em})"; }
    @media #{$query} { @content; }
  } @else {
    @warn "#{$break} is not valid to use as a breakpoint";
  }
}

// Root font-size in %, outputted in correct breakpoints.
@mixin rootsize {
  $values: map-values($rootsizes);
  $length: length($rootsizes);
  $points: map-values($breakpoints);
  @for $i from 1 through $length {
    @if nth($points, $i) == 0 { font-size: nth($values, $i) / 16 * 100%; }
    @else {
      @media screen and (min-width: nth($points, $i) / 16 * 1em ) {
        font-size: nth($values, $i) / 16 * 100%;
      }
    }
  }
}

// Font-size in rems. Work out a way to loop through greek letters - only work if those.
@mixin fontsize-0($value) {
  @if type-of($value) == number {
    font-size: #{$value / map-get($rootsizes, rootsize-0)}rem;
  } @else {
    font-size: #{map-fetch($modular-scale, scale-0 $value) / map-get($rootsizes, rootsize-0)}rem;
  }
}
@mixin fontsize-1($value) {
  @if type-of($value) == number {
    font-size: #{$value / map-get($rootsizes, rootsize-1)}rem;
  } @else {
    font-size: #{map-fetch($modular-scale, scale-1 $value) / map-get($rootsizes, rootsize-1)}rem;
  }
}
@mixin fontsize-2($value) {
  @if type-of($value) == number {
    font-size: #{$value / map-get($rootsizes, rootsize-2)}rem;
  } @else {
    font-size: #{map-fetch($modular-scale, scale-2 $value) / map-get($rootsizes, rootsize-2)}rem;
  }
}
@mixin fontsize-3($value) {
  @if type-of($value) == number {
    font-size: #{$value / map-get($rootsizes, rootsize-3)}rem;
  } @else {
    font-size: #{map-fetch($modular-scale, scale-3 $value) / map-get($rootsizes, rootsize-3)}rem;
  }
}
@mixin fontsize-4($value) {
  @if type-of($value) == number {
    font-size: #{$value / map-get($rootsizes, rootsize-4)}rem;
  } @else {
    font-size: #{map-fetch($modular-scale, scale-4 $value) / map-get($rootsizes, rootsize-4)}rem;
  }
}

// Set all fontsizes. Work out a way to loop through breakpoints.
@mixin fontsize-all($value) {
  @if number("#{$value}") != false {
    font-size: #{$value / map-get($rootsizes, rootsize-0)}rem;
  } @else {
    font-size: #{map-fetch($modular-scale, scale-0 $value) / map-get($rootsizes, rootsize-0)}rem;
  }
}

@mixin fontsize($fontsize, $breakpoint: 0) {
  @if type-of($fontsize) == number {
    font-size: #{$fontsize / map-get($rootsizes, rootsize-0)}rem;
  } @else if map-has-key($map, $fontsize){
    font-size: #{map-fetch($modular-scale, scale-0 $fontsize) / map-get($rootsizes, rootsize-0)}rem;
  }
}


// Extending Sass maps functionality to get into nested maps. https://gist.github.com/jlong/8760275
@function map-fetch($map, $keys) {
  $key: nth($keys, 1);
  $length: length($keys);
  $value: map-get($map, $key);
  @if ($length > 1) {
    $rest: ();
    @for $i from 2 through $length {
      $rest: append($rest, nth($keys, $i))
    }
    @return map-fetch($value, $rest)
  } @else {
    @return $value;
  }
}

@function has-in-scale($scale) {
  $test: map-get($modular-scale, $scale);
  $output: map-keys($test);
  @return $output;
}

// Clearfix.
@mixin clearfix {
  &:before, &:after{
    display: table;
    content: "";
  }
  &:after{
    clear: both;
  }
}
